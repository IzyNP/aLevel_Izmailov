# Insertion Sort

Сортировка — один из базовых видов активности или действий, выполняемых над предметами. Ещё в детсве детей учат сортировать, развивая мышление. Компьютеры и программы — тоже не исключение. Существует огромное множество алгоритмов. В данной статье мы рассмотрим и изучим Insertion Sort(далее - Сортировка вставками).


### Что такое сортировка вставками?

Сортировка вставками - алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов. Вычислительная сложность — **О(n2)**.

**Общая суть сортировок вставками такова**:

Перебираются элементы в неотсортированной части массива.
Каждый элемент вставляется в отсортированную часть массива на то место, где он должен находиться.

То есть, сортировки вставками всегда делят массив на 2 части — отсортированную и неотсортированную. Из неотсортированной части извлекается любой элемент. Поскольку другая часть массива отсортирована, то в ней достаточно быстро можно найти своё место для этого извлечённого элемента. Элемент вставляется куда нужно, в результате чего отсортированная часть массива увеличивается, а неотсортированная уменьшается. Всё. По такому принципу работают все сортировки вставками.

## Виды сортировки вставаками

1. **Сортировка _простыми_ вставками**

![пример](https://hsto.org/webt/x4/nz/uu/x4nzuuiuosxzaj2y88ewj-vu9zo.gif)

Проходим по массиву слева направо и обрабатываем по очереди каждый элемент. Слева от очередного элемента наращиваем отсортированную часть массива, справа по мере процесса потихоньку испаряется неотсортированная. В отсортированной части массива ищется точка вставки для очередного элемента. Сам элемент отправляется в буфер, в результате чего в массиве появляется свободная ячейка — это позволяет сдвинуть элементы и освободить точку вставки.

```
def insertion(data):
	for i in range(len(data)):
		j = i - 1 
		key = data[i]
		while data[j] > key and j >= 0:
			data[j + 1] = data[j]
			j -= 1
		data[j + 1] = key
	return data
```


На примере простых вставок показательно смотрится главное преимущество большинства (но не всех!) сортировок вставками, а именно — очень быстрая обработка почти упорядоченных массивов:

![пример](https://hsto.org/webt/qq/6e/ud/qq6eudehsux_10xmkh1b-x1sata.gif)

При таком раскладе даже самая примитивная реализация сортировки вставкам, скорее всего, обгонит супер-оптимизированный алгоритм какой-нибудь быстрой сортировки, в том числе и на больших массивах.

Этому способствует сама основная идея этого класса — переброска элементов из неотсортированной части массива в отсортированную. При близком расположении близких по величине данных место вставки обычно находится близко к краю отсортированной части, что позволяет вставлять с наименьшими накладными расходами.

Нет ничего лучше для обработки почти упорядоченных массивов чем сортировки вставками. Когда Вы где-то встречаете информацию, что лучшая временна́я сложность сортировки вставками равна **O(_n_)**, то, скорее всего, имеются в виду ситуации с почти упорядоченными массивами.

2.**Сортировка _Шелла_**

В 1959 году американский ученый Дональд Шелл опубликовал алгоритм сортировки, который впоследствии получил его имя – «Сортировка Шелла». Этот алгоритм может рассматриваться и как обобщение пузырьковой сортировки, так и сортировки вставками.

В этом алгоритме очень остроумный подход в определении того, какую именно часть массива считать отсортированной. В простых вставках все просто: от текущего элемента всё что слева — уже отсортировано, всё что справа — ещё не отсортировано. В отличие от простых вставок сортировка Шелла не пытается слева от элемента сразу формировать строго отсортированную часть массива. Она создаёт слева от элемента почти отсортированную часть массива и делает это достаточно быстро.

![пример](https://hsto.org/webt/ig/rb/aa/igrbaajcuoxuj4q-l-38x0qsoq4.gif)


- **_Худшее время_	—  O(n2)**

- **_Лучшее время_	—  O(n log2 n)**

- Среднее время	—  зависит от выбранных шагов

- Затраты памяти	—  **О(n)** всего, **O(1)** дополнительно

Реализуется данный алгоритм следующим способом:
```
void sort_shell(int[] a){
   int i, j, k, h, m=0, b=a.length;
   int[] d = { 1, 4, 10, 23, 57, 145, 356, 911, 1968, 4711, 11969, 27901,
               84801, 213331, 543749, 1355339, 3501671, 8810089, 21521774,
               58548857, 157840433, 410151271, 1131376761, 2147483647 };
   while (d[m] < b) ++m;
   while (--m >= 0){
      k = d[m];
      for (i = k; i < b; i++){     // k-сортировка
         j=i;
         h=a[i];
         while ((j >= k) && (a[j-k] > h)){
              a[j]=a[j-k];
              j -= k;
         }
         a[j] = h;
      }
   }
}
```

3.**Сортировка _деревом_**
![пример](https://hsto.org/webt/uo/6e/d8/uo6ed8lcpyvdpg9fzfwsye2pnuu.gif)

Процедура добавления объекта в бинарное дерево имеет среднюю алгоритмическую сложность порядка **O(log n)**. Соответственно, для n объектов сложность будет составлять **O(n log (n))**, что относит сортировку с помощью двоичного дерева к группе «быстрых сортировок». Однако, сложность добавления объекта в разбалансированное дерево может достигать **O(n)**, что может привести к общей сложности порядка **O(n2)**.

При физическом развёртывании древовидной структуры в памяти требуется не менее чем **_4n_** ячеек дополнительной памяти (каждый узел должен содержать ссылки на элемент исходного массива, на родительский элемент, на левый и правый лист), однако, существуют способы уменьшить требуемую дополнительную память.

Для сортировки с помощью дерева исходная сортируемая  последовательность представляется в виде структуры данных «дерево».

Основная загвоздка сортировок вставками (затраты на вставку элемента на своё место в отсортированной части массива) здесь решена, построение происходит вполне оперативно. Во всяком случае для освобождения точки вставки не нужно медленно передвигать караваны элементов как в предыдущих алгоритмах. Казалось бы, вот она, наилучшая из сортировок вставками. Но есть проблема.

Когда получается красивая симметричная ёлочка (так называемое идеально сбалансированное дерево) как в анимации тремя абзацами выше, то вставка происходит быстро, поскольку дерево в этом случае имеет минимально возможную вложенность уровней. Но сбалансированная (или хотя бы близкая к таковой) структура из рандомного массива получается редко. И дерево, скорее всего, будет неидеальное и несбалансированное — с перекосами, заваленным горизонтом и избыточным количеством уровней.


_Случайный массив со значениями от 1 до 10. Элементы в таком порядке генерируют несбалансированное двоичное дерево:_
![пример](https://hsto.org/r/w1560/webt/io/mj/25/iomj25xs6mtppplwt02gdgmbsiq.png)

Чем больше несбалансированности — тем сильнее будет буксовать алгоритм по обходу дерева

_Значения элементов те же, но порядок другой. Генерируется сбалансированное двоичное дерево:_
![пример](https://hsto.org/r/w1560/webt/sc/k8/_y/sck8_y-fbutnw-ulr6bg1rg4nbg.png)

Проблему несбалансированных деревьев решает сортировка выворачиванием, которая использует особую разновидность бинарного дерева поиска — **_splay tree_**.

**Splay tree**	—  расширяющееся или косое дерево является двоичным деревом поиска, в котором поддерживается свойство сбалансированности. Это дерево принадлежит классу «саморегулирующихся деревьев», которые поддерживают необходимый баланс ветвления дерева, чтобы обеспечить выполнение операций поиска, добавления и удаления за логарифмическое время от числа хранимых элементов. Это реализуется без использования каких-либо дополнительных полей в узлах дерева (как, например, в Красно-чёрных деревьях или АВЛ-деревьях, где в вершинах хранится, соответственно, цвет вершины и глубина поддерева). Вместо этого «расширяющие операции» (splay operation), частью которых являются вращения, выполняются при каждом обращении к дереву.

Учётная стоимость в расчёте на одну операцию с деревом составляет **O(log n)**.

Расширяющееся дерево придумали Роберт Тарьян и Даниель Слейтор в 1983 году.

**_Реализация данного дерева выглядит следующим образом_**:
```
// Java implementation for above approach
// Реализация подхода, приведенного выше, на Java
class GFG
{
  
// Узел АВЛ-дерева 
static class node 
{ 
  
    int key; 
    node left, right; 
}; 
  
/ * Вспомогательная функция, которая выделяет 
новый узел с заданным key и left и right, указывающими в NULL. * /
static node newNode(int key) 
{ 
    node Node = new node();
    Node.key = key; 
    Node.left = Node.right = null; 
    return (Node); 
} 
  
// Служебная функция для разворота поддерева с корнем y вправо.
// Смотрите диаграмму, приведенную выше.
static node rightRotate(node x) 
{ 
    node y = x.left; 
    x.left = y.right; 
    y.right = x; 
    return y; 
} 
  
// Служебная функция для разворота поддерева с корнем x влево 
// Смотрите диаграмму, приведенную выше. 
static node leftRotate(node x) 
{ 
    node y = x.right; 
    x.right = y.left; 
    y.left = x; 
    return y; 
} 
  
// Эта функция поднимет ключ
// в корень, если он присутствует в дереве. 
// Если такой ключ отсутствует в дереве, она
// поднимет в корень самый последний элемент,
// к которому был осуществлен доступ.
// Эта функция изменяет дерево
// и возвращает новый корень (root).
static node splay(node root, int key) 
{ 
    // Базовые случаи: root равен NULL или
    // ключ находится в корне
    if (root == null || root.key == key) 
        return root; 
  
    // Ключ лежит в левом поддереве
    if (root.key > key) 
    { 
        // Ключа нет в дереве, мы закончили
        if (root.left == null) return root; 
  
        // Zig-Zig (Левый-левый) 
        if (root.left.key > key) 
        { 
            // Сначала рекурсивно поднимем
            // ключ как корень left-left 
            root.left.left = splay(root.left.left, key); 
  
            // Первый разворот для root, 
            // второй разворот выполняется после else
            root = rightRotate(root); 
        } 
        else if (root.left.key < key) // Zig-Zag (Left Right) 
        { 
            // Сначала рекурсивно поднимаем
            // ключ как корень left-right 
            root.left.right = splay(root.left.right, key); 
  
            // Выполняем первый разворот для root.left
            if (root.left.right != null) 
                root.left = leftRotate(root.left); 
        } 
  
        // Выполняем второй разворот для корня
        return (root.left == null) ? 
                              root : rightRotate(root); 
    } 
    else // Ключ находится в правом поддереве 
    { 
        // Ключа нет в дереве, мы закончили 
        if (root.right == null) return root; 
  
        // Zag-Zig (Правый-левый) 
        if (root.right.key > key) 
        { 
            //Поднять ключ как корень right-left
            root.right.left = splay(root.right.left, key); 
  
            // Выполняем первый поворот для root.right
            if (root.right.left != null) 
                root.right = rightRotate(root.right); 
        } 
        else if (root.right.key < key)// Zag-Zag (Правый-правый) 
        { 
            // Поднимаем ключ как корень 
            // right-right и выполняем первый разворот
            root.right.right = splay(root.right.right, key); 
            root = leftRotate(root); 
        } 
  
        //Выполняем второй разворот для root 
        return (root.right == null) ? 
                               root : leftRotate(root); 
    } 
} 
  
// Функция поиска для splay-дерева. 
// Обратите внимание, что эта функция возвращает 
// новый корень splay-дерева. Если ключ 
// присутствует в дереве, он перемещается в корень.
static node search(node root, int key) 
{ 
    return splay(root, key); 
} 
  
// Служебная функция для вывода 
// обхода в дерева ширину. 
// Функция также выводит высоту каждого узла 
static void preOrder(node root) 
{ 
    if (root != null) 
    { 
        System.out.print(root.key + " "); 
        preOrder(root.left); 
        preOrder(root.right); 
    } 
} 
  
// Управляющий код

public static void main(String[] args) 
{ 
    node root = newNode(100); 
    root.left = newNode(50); 
    root.right = newNode(200); 
    root.left.left = newNode(40); 
    root.left.left.left = newNode(30); 
    root.left.left.left.left = newNode(20); 
  
    root = search(root, 20); 
    System.out.print("Preorder traversal of the" +  
                     " modified Splay tree is \n"); 
    preOrder(root); 
} 
} 
```
